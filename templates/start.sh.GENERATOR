#!/bin/sh

# navigate to templates directory
cd "$(dirname "$0")" || exit 1

if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
	echo "Generate a startup script for a 'local' or 'remote' environment."
	exit 0
fi

# get environment: 'local' or 'remote'
if [ "$1" = "local" ]; then
	env_choice="local"
elif [ "$1" = "remote" ]; then
	env_choice="remote"
else
	echo "First positional argument must be one of: local, remote"
	exit 1
fi

# check for existing .env values
if [ -f ../.env ]; then
	# source dotenv
	set -o allexport
	# shellcheck disable=SC1091
	. ../.env
	set +o allexport
else
	echo "Could not find existing environment at '.env'. This is not an error."
fi

# create initial boilerplate
boilerplate="#!/bin/sh

# navigate to project root directory
cd \$(dirname \"\$0\")" || exit

# environment-specific values
if [ "$USE_PODMAN" = 1 ]; then
	# podman
	container_environment_message="This environment has been configured for use with Podman. To use this service with Docker, re-run the setup script (or use the start.sh generator script) without setting the environment variable 'USE_PODMAN=1'."
	startup_command="docker-compose -H unix:${DOCKER_HOST}"
else
	# docker
	container_environment_message="This environment has been configured for use with Docker. To use this service with Podman, re-run the setup script (or use the start.sh generator script) with the environment variable 'USE_PODMAN=1'."
	startup_command="docker compose"
fi

# print result
echo "$boilerplate

echo \"$container_environment_message\"

exec $startup_command -f compose.yaml -f compose.config-${env_choice}.yaml up \"\$@\""
